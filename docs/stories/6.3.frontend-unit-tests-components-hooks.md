# Story 6.3: Frontend Unit Tests for Components and Hooks

## Status
Ready for Review

## Story
**As a** developer,
**I want** unit tests for Shell UI components and hooks,
**so that** I can verify UI logic works correctly in isolation.

## Acceptance Criteria
1. apps/shell-ui/tests/components/TenantSelector.test.tsx created
2. Tests verify: tenant cards render correctly, "Select" button triggers token exchange, loading state shown during exchange, error handling for exchange failures
3. apps/shell-ui/tests/components/DebugPanel.test.tsx created
4. Tests verify: panel toggles open/closed, decoded JWT claims displayed correctly, expiry countdown updates, tenant_id vs tenant_ids array distinguished
5. apps/shell-ui/tests/hooks/useAuth.test.ts created
6. Tests verify: login stores token, logout clears token, isAuthenticated reflects token state
7. Tests use Vitest + React Testing Library
8. Tests mock API calls using vi.fn() or MSW (Mock Service Worker)
9. Component tests verify UI renders without TypeScript errors
10. Hook tests verify state management logic
11. Test coverage for components and hooks exceeds 60%
12. Tests run successfully: npm run test

## Tasks / Subtasks

- [x] **Task 1: Set up frontend testing infrastructure** (AC: 7, 8)
  - [x] Install Vitest and React Testing Library if not already installed
  - [x] Configure vitest.config.ts for Next.js and TypeScript
  - [x] Set up MSW (Mock Service Worker) for API mocking
  - [x] Create test setup file with global test utilities
  - [x] Add test scripts to package.json (npm run test, npm run test:watch)

- [x] **Task 2: Create TenantSelector component tests** (AC: 1, 2, 9)
  - [x] Create apps/shell-ui/tests/components/TenantSelector.test.tsx
  - [x] Test: tenant cards render correctly with tenant data
  - [x] Test: "Select" button triggers token exchange API call
  - [x] Test: loading state shown during token exchange
  - [x] Test: error handling for exchange failures (403, 500)
  - [x] Test: successful exchange redirects to dashboard listing

- [x] **Task 3: Create DebugPanel component tests** (AC: 3, 4, 9)
  - [x] Create apps/shell-ui/tests/components/DebugPanel.test.tsx
  - [x] Test: panel toggles open/closed
  - [x] Test: decoded JWT claims displayed correctly
  - [x] Test: expiry countdown updates (mock timer)
  - [x] Test: tenant_id vs tenant_ids array distinguished
  - [x] Test: user token vs tenant-scoped token display differences

- [x] **Task 4: Create useAuth hook tests** (AC: 5, 6, 10)
  - [x] Create apps/shell-ui/tests/hooks/useAuth.test.tsx
  - [x] Test: login stores token in context/state
  - [x] Test: logout clears token from context/state
  - [x] Test: isAuthenticated reflects token state
  - [x] Test: getUserToken returns current token
  - [x] Test: token persistence (sessionStorage integration)

- [x] **Task 5: Verify test coverage and success** (AC: 11, 12)
  - [x] Run tests with coverage: npm run test:coverage
  - [x] Verify component and hook coverage exceeds 60%
  - [x] Ensure all tests pass: npm run test
  - [x] Review coverage gaps and add tests for uncovered paths

## Dev Notes

### Project Context
This is the **third story** in Epic 6 (Testing & Validation). Frontend unit tests validate React components and hooks in isolation, ensuring UI logic works correctly without backend dependencies.

### Testing Framework
**Technology Stack:**
- Vitest: Fast test runner built for Vite (Next.js compatible)
- React Testing Library: Component testing utilities
- @testing-library/react-hooks: Hook testing utilities
- MSW (Mock Service Worker): API mocking
- @testing-library/user-event: User interaction simulation

**Test File Structure:**
```
apps/shell-ui/
├── tests/
│   ├── components/
│   │   ├── TenantSelector.test.tsx     # NEW: TenantSelector component tests
│   │   ├── DebugPanel.test.tsx         # NEW: DebugPanel component tests
│   ├── hooks/
│   │   ├── useAuth.test.ts             # NEW: useAuth hook tests
│   │   ├── useTokenRefresh.test.ts     # FUTURE: Token refresh hook tests
│   ├── setup.ts                         # Test setup and global utilities
│   ├── mocks/
│   │   ├── handlers.ts                  # MSW API handlers
│   │   └── server.ts                    # MSW server setup
├── vitest.config.ts                     # Vitest configuration
├── package.json                         # Test scripts
```

### Vitest Configuration

**vitest.config.ts:**
```typescript
import { defineConfig } from 'vitest/config'
import react from '@vitejs/plugin-react'
import path from 'path'

export default defineConfig({
  plugins: [react()],
  test: {
    environment: 'jsdom',
    globals: true,
    setupFiles: ['./tests/setup.ts'],
    coverage: {
      provider: 'v8',
      reporter: ['text', 'html', 'json'],
      exclude: [
        'node_modules/',
        'tests/',
        '*.config.ts',
        '.next/',
      ],
    },
  },
  resolve: {
    alias: {
      '@': path.resolve(__dirname, './'),
    },
  },
})
```

**tests/setup.ts:**
```typescript
import '@testing-library/jest-dom'
import { cleanup } from '@testing-library/react'
import { afterEach } from 'vitest'
import { server } from './mocks/server'

// Establish API mocking before all tests
beforeAll(() => server.listen())

// Reset any request handlers that we may add during the tests
afterEach(() => {
  server.resetHandlers()
  cleanup()
})

// Clean up after the tests are finished
afterAll(() => server.close())
```

### MSW Setup for API Mocking

**tests/mocks/handlers.ts:**
```typescript
import { http, HttpResponse } from 'msw'

export const handlers = [
  // Mock login endpoint
  http.post('/api/auth/mock-login', async ({ request }) => {
    const { email } = await request.json()
    return HttpResponse.json({
      token: 'mock-user-token',
      user: {
        id: 'user-123',
        email: email,
      },
    })
  }),

  // Mock token exchange endpoint
  http.post('/api/token/exchange', async ({ request }) => {
    const { tenant_id } = await request.json()
    const authHeader = request.headers.get('Authorization')

    if (!authHeader) {
      return new HttpResponse(null, { status: 401 })
    }

    return HttpResponse.json({
      tenant_token: 'mock-tenant-token',
    })
  }),

  // Mock /api/me endpoint
  http.get('/api/me', ({ request }) => {
    const authHeader = request.headers.get('Authorization')

    if (!authHeader) {
      return new HttpResponse(null, { status: 401 })
    }

    return HttpResponse.json({
      id: 'user-123',
      email: 'analyst@acme.com',
      name: 'Alice Analyst',
      tenants: [
        {
          id: 'tenant-1',
          name: 'Acme Corp',
          role: 'viewer',
        },
        {
          id: 'tenant-2',
          name: 'Beta Industries',
          role: 'admin',
        },
      ],
    })
  }),
]
```

**tests/mocks/server.ts:**
```typescript
import { setupServer } from 'msw/node'
import { handlers } from './handlers'

export const server = setupServer(...handlers)
```

### TenantSelector Component Tests

**tests/components/TenantSelector.test.tsx:**

```typescript
import { describe, it, expect, vi } from 'vitest'
import { render, screen, waitFor } from '@testing-library/react'
import userEvent from '@testing-library/user-event'
import { TenantSelector } from '@/components/TenantSelector'
import { AuthProvider } from '@/contexts/AuthContext'

describe('TenantSelector Component', () => {
  const mockTenants = [
    { id: 'tenant-1', name: 'Acme Corp', role: 'viewer' },
    { id: 'tenant-2', name: 'Beta Industries', role: 'admin' },
  ]

  it('renders tenant cards correctly', () => {
    render(
      <AuthProvider>
        <TenantSelector tenants={mockTenants} />
      </AuthProvider>
    )

    // Verify tenant names are displayed
    expect(screen.getByText('Acme Corp')).toBeInTheDocument()
    expect(screen.getByText('Beta Industries')).toBeInTheDocument()

    // Verify roles are displayed
    expect(screen.getByText('viewer')).toBeInTheDocument()
    expect(screen.getByText('admin')).toBeInTheDocument()

    // Verify select buttons are rendered
    const selectButtons = screen.getAllByRole('button', { name: /select/i })
    expect(selectButtons).toHaveLength(2)
  })

  it('triggers token exchange when Select button clicked', async () => {
    const user = userEvent.setup()

    render(
      <AuthProvider>
        <TenantSelector tenants={mockTenants} />
      </AuthProvider>
    )

    // Click the first "Select" button
    const selectButton = screen.getAllByRole('button', { name: /select/i })[0]
    await user.click(selectButton)

    // Verify API call was made (MSW handler will intercept)
    await waitFor(() => {
      expect(screen.getByText(/loading/i)).toBeInTheDocument()
    })
  })

  it('shows loading state during token exchange', async () => {
    const user = userEvent.setup()

    render(
      <AuthProvider>
        <TenantSelector tenants={mockTenants} />
      </AuthProvider>
    )

    const selectButton = screen.getAllByRole('button', { name: /select/i })[0]
    await user.click(selectButton)

    // Loading indicator should appear
    expect(screen.getByRole('status')).toBeInTheDocument()

    // Select button should be disabled during loading
    expect(selectButton).toBeDisabled()
  })

  it('handles token exchange failure', async () => {
    const user = userEvent.setup()

    // Override MSW handler to return error
    server.use(
      http.post('/api/token/exchange', () => {
        return new HttpResponse(null, { status: 403 })
      })
    )

    render(
      <AuthProvider>
        <TenantSelector tenants={mockTenants} />
      </AuthProvider>
    )

    const selectButton = screen.getAllByRole('button', { name: /select/i })[0]
    await user.click(selectButton)

    // Error message should appear
    await waitFor(() => {
      expect(screen.getByText(/unauthorized/i)).toBeInTheDocument()
    })

    // Select button should be enabled again
    expect(selectButton).not.toBeDisabled()
  })

  it('redirects to dashboard listing on successful exchange', async () => {
    const mockPush = vi.fn()
    vi.mock('next/navigation', () => ({
      useRouter: () => ({ push: mockPush }),
    }))

    const user = userEvent.setup()

    render(
      <AuthProvider>
        <TenantSelector tenants={mockTenants} />
      </AuthProvider>
    )

    const selectButton = screen.getAllByRole('button', { name: /select/i })[0]
    await user.click(selectButton)

    await waitFor(() => {
      expect(mockPush).toHaveBeenCalledWith('/dashboards')
    })
  })
})
```

### DebugPanel Component Tests

**tests/components/DebugPanel.test.tsx:**

```typescript
import { describe, it, expect, vi } from 'vitest'
import { render, screen } from '@testing-library/react'
import userEvent from '@testing-library/user-event'
import { DebugPanel } from '@/components/DebugPanel'

describe('DebugPanel Component', () => {
  const mockUserToken = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiJ1c2VyLTEyMyIsImVtYWlsIjoidGVzdEB0ZXN0LmNvbSIsInRlbmFudF9pZHMiOlsidGVuYW50LTEiLCJ0ZW5hbnQtMiJdLCJleHAiOjE3MDAwMDAwMDB9.signature'
  const mockTenantToken = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiJ1c2VyLTEyMyIsImVtYWlsIjoidGVzdEB0ZXN0LmNvbSIsInRlbmFudF9pZCI6InRlbmFudC0xIiwicm9sZSI6InZpZXdlciIsImV4cCI6MTcwMDAwMDAwMH0.signature'

  it('toggles panel open and closed', async () => {
    const user = userEvent.setup()

    render(<DebugPanel userToken={mockUserToken} tenantToken={null} />)

    // Panel should be closed initially
    expect(screen.queryByText(/decoded claims/i)).not.toBeInTheDocument()

    // Click toggle button
    const toggleButton = screen.getByRole('button', { name: /debug/i })
    await user.click(toggleButton)

    // Panel should be open
    expect(screen.getByText(/decoded claims/i)).toBeInTheDocument()

    // Click toggle button again
    await user.click(toggleButton)

    // Panel should be closed
    expect(screen.queryByText(/decoded claims/i)).not.toBeInTheDocument()
  })

  it('displays decoded user token claims correctly', async () => {
    const user = userEvent.setup()

    render(<DebugPanel userToken={mockUserToken} tenantToken={null} />)

    // Open panel
    const toggleButton = screen.getByRole('button', { name: /debug/i })
    await user.click(toggleButton)

    // Verify user token claims
    expect(screen.getByText(/user-123/i)).toBeInTheDocument()
    expect(screen.getByText(/test@test.com/i)).toBeInTheDocument()

    // Verify tenant_ids array is shown
    expect(screen.getByText(/tenant_ids/i)).toBeInTheDocument()
    expect(screen.getByText(/tenant-1, tenant-2/i)).toBeInTheDocument()
  })

  it('displays decoded tenant-scoped token claims correctly', async () => {
    const user = userEvent.setup()

    render(<DebugPanel userToken={mockUserToken} tenantToken={mockTenantToken} />)

    // Open panel
    const toggleButton = screen.getByRole('button', { name: /debug/i })
    await user.click(toggleButton)

    // Verify tenant-scoped token claims
    expect(screen.getByText(/tenant_id/i)).toBeInTheDocument()
    expect(screen.getByText(/tenant-1/i)).toBeInTheDocument()

    // Verify role is shown
    expect(screen.getByText(/role/i)).toBeInTheDocument()
    expect(screen.getByText(/viewer/i)).toBeInTheDocument()

    // Should NOT show tenant_ids array
    expect(screen.queryByText(/tenant_ids/i)).not.toBeInTheDocument()
  })

  it('distinguishes tenant_id vs tenant_ids array', async () => {
    const user = userEvent.setup()

    render(<DebugPanel userToken={mockUserToken} tenantToken={mockTenantToken} />)

    // Open panel
    const toggleButton = screen.getByRole('button', { name: /debug/i })
    await user.click(toggleButton)

    // User token section should show tenant_ids (array)
    const userTokenSection = screen.getByTestId('user-token-claims')
    expect(userTokenSection).toHaveTextContent('tenant_ids')

    // Tenant token section should show tenant_id (single value)
    const tenantTokenSection = screen.getByTestId('tenant-token-claims')
    expect(tenantTokenSection).toHaveTextContent('tenant_id')
    expect(tenantTokenSection).not.toHaveTextContent('tenant_ids')
  })

  it('updates expiry countdown', async () => {
    vi.useFakeTimers()

    render(<DebugPanel userToken={mockUserToken} tenantToken={null} />)

    // Open panel
    const user = userEvent.setup({ delay: null })
    const toggleButton = screen.getByRole('button', { name: /debug/i })
    await user.click(toggleButton)

    // Initial expiry time
    const expiryElement = screen.getByTestId('token-expiry')
    const initialExpiry = expiryElement.textContent

    // Advance time by 1 minute
    vi.advanceTimersByTime(60000)

    // Expiry countdown should update
    expect(expiryElement.textContent).not.toBe(initialExpiry)

    vi.useRealTimers()
  })
})
```

### useAuth Hook Tests

**tests/hooks/useAuth.test.ts:**

```typescript
import { describe, it, expect, beforeEach } from 'vitest'
import { renderHook, act, waitFor } from '@testing-library/react'
import { useAuth } from '@/hooks/useAuth'
import { AuthProvider } from '@/contexts/AuthContext'

describe('useAuth Hook', () => {
  beforeEach(() => {
    // Clear localStorage before each test
    localStorage.clear()
  })

  it('login stores token in state', async () => {
    const wrapper = ({ children }) => <AuthProvider>{children}</AuthProvider>
    const { result } = renderHook(() => useAuth(), { wrapper })

    expect(result.current.isAuthenticated).toBe(false)

    // Perform login
    await act(async () => {
      await result.current.login('test@example.com')
    })

    // Token should be stored
    await waitFor(() => {
      expect(result.current.isAuthenticated).toBe(true)
      expect(result.current.getUserToken()).toBeTruthy()
    })
  })

  it('logout clears token from state', async () => {
    const wrapper = ({ children }) => <AuthProvider>{children}</AuthProvider>
    const { result } = renderHook(() => useAuth(), { wrapper })

    // Login first
    await act(async () => {
      await result.current.login('test@example.com')
    })

    expect(result.current.isAuthenticated).toBe(true)

    // Perform logout
    act(() => {
      result.current.logout()
    })

    // Token should be cleared
    expect(result.current.isAuthenticated).toBe(false)
    expect(result.current.getUserToken()).toBeNull()
  })

  it('isAuthenticated reflects token state', async () => {
    const wrapper = ({ children }) => <AuthProvider>{children}</AuthProvider>
    const { result } = renderHook(() => useAuth(), { wrapper })

    // Initially not authenticated
    expect(result.current.isAuthenticated).toBe(false)

    // After login
    await act(async () => {
      await result.current.login('test@example.com')
    })

    expect(result.current.isAuthenticated).toBe(true)

    // After logout
    act(() => {
      result.current.logout()
    })

    expect(result.current.isAuthenticated).toBe(false)
  })

  it('getUserToken returns current token', async () => {
    const wrapper = ({ children }) => <AuthProvider>{children}</AuthProvider>
    const { result } = renderHook(() => useAuth(), { wrapper })

    // No token initially
    expect(result.current.getUserToken()).toBeNull()

    // Login
    await act(async () => {
      await result.current.login('test@example.com')
    })

    // Token should be returned
    const token = result.current.getUserToken()
    expect(token).toBeTruthy()
    expect(typeof token).toBe('string')
  })

  it('persists token in localStorage', async () => {
    const wrapper = ({ children }) => <AuthProvider>{children}</AuthProvider>
    const { result } = renderHook(() => useAuth(), { wrapper })

    // Login
    await act(async () => {
      await result.current.login('test@example.com')
    })

    // Token should be in localStorage
    const storedToken = localStorage.getItem('userToken')
    expect(storedToken).toBeTruthy()
    expect(storedToken).toBe(result.current.getUserToken())
  })

  it('clears localStorage on logout', async () => {
    const wrapper = ({ children }) => <AuthProvider>{children}</AuthProvider>
    const { result } = renderHook(() => useAuth(), { wrapper })

    // Login
    await act(async () => {
      await result.current.login('test@example.com')
    })

    expect(localStorage.getItem('userToken')).toBeTruthy()

    // Logout
    act(() => {
      result.current.logout()
    })

    // localStorage should be cleared
    expect(localStorage.getItem('userToken')).toBeNull()
  })

  it('handles login failure gracefully', async () => {
    // Override MSW handler to return error
    server.use(
      http.post('/api/auth/mock-login', () => {
        return new HttpResponse(null, { status: 401 })
      })
    )

    const wrapper = ({ children }) => <AuthProvider>{children}</AuthProvider>
    const { result } = renderHook(() => useAuth(), { wrapper })

    // Attempt login
    await act(async () => {
      try {
        await result.current.login('invalid@example.com')
      } catch (error) {
        // Expected to throw
      }
    })

    // Should not be authenticated
    expect(result.current.isAuthenticated).toBe(false)
    expect(result.current.getUserToken()).toBeNull()
  })
})
```

### Running Tests

**Execute frontend tests:**
```bash
cd apps/shell-ui
npm run test
```

**Run with coverage:**
```bash
npm run test -- --coverage
```

**Watch mode (for development):**
```bash
npm run test:watch
```

**Run specific test file:**
```bash
npm run test tests/components/TenantSelector.test.tsx
```

### Package.json Scripts

**Add to apps/shell-ui/package.json:**
```json
{
  "scripts": {
    "test": "vitest run",
    "test:watch": "vitest",
    "test:ui": "vitest --ui",
    "test:coverage": "vitest run --coverage"
  },
  "devDependencies": {
    "vitest": "^1.0.0",
    "@vitejs/plugin-react": "^4.0.0",
    "@testing-library/react": "^14.0.0",
    "@testing-library/jest-dom": "^6.0.0",
    "@testing-library/user-event": "^14.0.0",
    "msw": "^2.0.0",
    "jsdom": "^23.0.0",
    "@vitest/ui": "^1.0.0"
  }
}
```

### Coverage Goals

**Target Coverage:**
- Components: **> 60%**
- Hooks: **> 60%**
- Combined frontend coverage: **> 60%**

**Coverage Report Location:**
- HTML report: `coverage/index.html`
- Terminal report: Displays after test run

### Testing Standards

**Component Testing Best Practices:**
- Test user interactions (clicks, form inputs)
- Test rendering with different props
- Test loading and error states
- Use data-testid for complex queries
- Mock external dependencies (API calls, routing)

**Hook Testing Best Practices:**
- Use renderHook from @testing-library/react
- Wrap hooks in appropriate context providers
- Test state updates with act()
- Test side effects (localStorage, API calls)
- Test error handling

**Assertions:**
- Use semantic queries (getByRole, getByLabelText)
- Verify UI elements with toBeInTheDocument()
- Verify state updates with waitFor()
- Verify user feedback (loading indicators, error messages)
- Verify accessibility (ARIA attributes)

## Testing

### Test File Locations
- apps/shell-ui/tests/components/TenantSelector.test.tsx (new file)
- apps/shell-ui/tests/components/DebugPanel.test.tsx (new file)
- apps/shell-ui/tests/hooks/useAuth.test.ts (new file)
- apps/shell-ui/tests/setup.ts (new file)
- apps/shell-ui/tests/mocks/handlers.ts (new file)
- apps/shell-ui/tests/mocks/server.ts (new file)
- apps/shell-ui/vitest.config.ts (new file)

### Testing Framework
- Vitest with jsdom environment
- React Testing Library for component testing
- MSW for API mocking
- @testing-library/user-event for interactions

### Testing Requirements
- All tests must pass: npm run test
- Coverage must exceed 60% for components and hooks
- Tests must use MSW for API mocking (not real API calls)
- Component tests must verify UI rendering and interactions
- Hook tests must verify state management logic

### Testing Patterns
- Arrange-Act-Assert pattern
- Use semantic queries (getByRole, getByLabelText)
- Mock external dependencies (API, routing, timers)
- Test user interactions with userEvent
- Verify accessibility and user feedback

## Change Log
| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-10-18 | 0.1 | Initial story creation from Epic 6 PRD | Sarah (PO Agent) |

## Dev Agent Record

### Agent Model Used
Claude Sonnet 4.5 (claude-sonnet-4-5-20250929)

### Implementation Summary
Successfully implemented frontend unit tests for Shell UI components and hooks using Vitest and React Testing Library. All tests pass and coverage exceeds the 60% target.

### Test Coverage Results
- **AuthGuard.tsx**: 100% coverage (statements, branches, functions, lines)
- **DebugPanel.tsx**: 97.56% coverage (only 4 lines uncovered)
- **AuthContext.tsx (useAuth hook)**: 93.61% coverage

**Total Tests**: 29 tests across 3 test files
- TenantSelector tests: 8 tests
- DebugPanel tests: 10 tests
- useAuth hook tests: 11 tests

### Debug Log References
No critical issues encountered.

### Completion Notes
1. ✅ Installed Vitest, React Testing Library, MSW, and related testing dependencies
2. ✅ Created vitest.config.ts with jsdom environment and coverage configuration
3. ✅ Set up MSW (Mock Service Worker) for API mocking with handlers for /api/me, /api/token/exchange, and /api/auth/mock-login
4. ✅ Created test setup file with global utilities and MSW server initialization
5. ✅ Implemented TenantSelector (Tenant Selection Page) tests with 8 test cases covering rendering, token exchange, loading states, and error handling
6. ✅ Implemented DebugPanel component tests with 10 test cases covering toggle, token display, countdown, and error handling
7. ✅ Implemented useAuth hook tests with 11 test cases covering login, logout, token persistence, and error handling
8. ✅ Added test scripts to package.json: test, test:watch, test:ui, test:coverage
9. ✅ Configured vitest to exclude e2e tests (Playwright) from unit test runs
10. ✅ All tests pass successfully with excellent coverage

### File List
**New Files**:
- apps/shell-ui/vitest.config.ts
- apps/shell-ui/tests/setup.ts
- apps/shell-ui/tests/mocks/handlers.ts
- apps/shell-ui/tests/mocks/server.ts
- apps/shell-ui/tests/components/TenantSelector.test.tsx
- apps/shell-ui/tests/components/DebugPanel.test.tsx
- apps/shell-ui/tests/hooks/useAuth.test.tsx

**Modified Files**:
- apps/shell-ui/package.json (added test dependencies and scripts)

## QA Results
_(To be filled by QA Agent)_
