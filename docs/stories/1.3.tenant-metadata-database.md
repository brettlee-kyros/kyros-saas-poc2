# Story 1.3: Tenant Metadata Database Schema and Seed Scripts

## Status
Ready for Review

## Story
**As a** developer,
**I want** a SQLite database with PostgreSQL-compatible schema and automated seed scripts,
**so that** the PoC has consistent tenant metadata for testing without manual SQL entry, and the schema can migrate to PostgreSQL for MVP.

## Acceptance Criteria
1. database/schema.sql contains CREATE TABLE statements for: tenants, users, user_tenants, dashboards, tenant_dashboards
2. Schema uses PostgreSQL-compatible types: TEXT for UUIDs, INTEGER for booleans, TEXT for JSONB, TEXT for timestamps (ISO 8601)
3. Foreign key constraints defined with ON DELETE CASCADE for referential integrity
4. Indexes created on: tenants.slug, users.email, user_tenants(user_id), user_tenants(tenant_id), tenant_dashboards(tenant_id)
5. scripts/seed-database.py script creates data/tenant_metadata.db and executes schema.sql
6. Seed script inserts 2 mock tenants (Acme Corporation, Beta Industries) with config_json including branding fields
7. Seed script inserts 3 mock users with different tenant access patterns (single tenant, multi-tenant, different tenant)
8. Seed script inserts 2 dashboard definitions (customer-lifetime-value, risk-analysis) with config_json
9. Seed script creates tenant_dashboards assignments (Acme has both dashboards, Beta has only risk-analysis)
10. scripts/validate-database.py script queries database and verifies expected records exist, printing validation report
11. Seed script is idempotent - running multiple times drops and recreates database cleanly

## Tasks / Subtasks
- [ ] **Task 1: Create database schema file** (AC: 1, 2, 3)
  - [ ] Create `database/schema.sql` file
  - [ ] Add PRAGMA foreign_keys = ON for SQLite
  - [ ] Define `tenants` table with PostgreSQL-compatible types
  - [ ] Define `users` table with user_id (UUID), email
  - [ ] Define `user_tenants` junction table with role constraint
  - [ ] Define `dashboards` table with slug as PK (PoC simplification)
  - [ ] Define `tenant_dashboards` junction table
  - [ ] Add all foreign key constraints with ON DELETE CASCADE
  - [ ] Document PostgreSQL migration notes in comments

- [ ] **Task 2: Create database indexes** (AC: 4)
  - [ ] Create index on `tenants.slug` (frequently queried for routing)
  - [ ] Create index on `tenants.is_active`
  - [ ] Create index on `users.email` (for user lookup)
  - [ ] Create index on `user_tenants(user_id)` (for user's tenant list)
  - [ ] Create index on `user_tenants(tenant_id)` (for tenant's users)
  - [ ] Create index on `tenant_dashboards(tenant_id)` (for tenant's dashboards)
  - [ ] Create index on `tenant_dashboards(slug)` (for dashboard's tenants)

- [ ] **Task 3: Add seed data to schema** (AC: 6, 7, 8, 9)
  - [ ] Add INSERT statements for 2 mock tenants (Acme, Beta) with UUIDs and config_json
  - [ ] Add INSERT statements for 3 mock users matching shared-config mock data
  - [ ] Add INSERT statements for user_tenants mappings (viewer Acme, admin both, viewer Beta)
  - [ ] Add INSERT statements for 2 dashboards (customer-lifetime-value, risk-analysis)
  - [ ] Add INSERT statements for tenant_dashboards (Acme: both, Beta: risk only)
  - [ ] Verify all UUIDs match those in shared-config mock_users.py

- [ ] **Task 4: Create seed-database.py script** (AC: 5, 11)
  - [ ] Create `scripts/seed-database.py` Python script
  - [ ] Add logic to remove existing database file if present (idempotency)
  - [ ] Create `data/` directory if it doesn't exist
  - [ ] Connect to SQLite at `data/tenant_metadata.db`
  - [ ] Read and execute `database/schema.sql` (including seed data)
  - [ ] Add error handling and logging
  - [ ] Add success confirmation message with record counts
  - [ ] Make script executable (chmod +x)

- [ ] **Task 5: Create validate-database.py script** (AC: 10)
  - [ ] Create `scripts/validate-database.py` Python script
  - [ ] Connect to `data/tenant_metadata.db`
  - [ ] Query and count records in each table
  - [ ] Verify 2 tenants exist (Acme Corporation, Beta Industries)
  - [ ] Verify 3 users exist with correct emails
  - [ ] Verify 4 user_tenants mappings exist
  - [ ] Verify 2 dashboards exist
  - [ ] Verify 3 tenant_dashboards assignments
  - [ ] Print formatted validation report
  - [ ] Return exit code 0 if valid, 1 if any checks fail

- [ ] **Task 6: Test seed script idempotency** (AC: 11)
  - [ ] Run `scripts/seed-database.py` first time
  - [ ] Verify database created successfully
  - [ ] Run validation script and confirm all records present
  - [ ] Run seed script second time (should drop and recreate)
  - [ ] Run validation again and verify data is identical
  - [ ] Confirm no errors or data duplication

- [ ] **Task 7: Document database setup** (AC: 1-11)
  - [ ] Add database setup section to root README.md
  - [ ] Document how to run seed script: `python scripts/seed-database.py`
  - [ ] Document how to validate: `python scripts/validate-database.py`
  - [ ] Document database location: `data/tenant_metadata.db`
  - [ ] Add schema evolution notes for MVP PostgreSQL migration
  - [ ] Document mock tenant credentials and IDs for testing

- [ ] **Task 8: Verify all acceptance criteria** (AC: 1-11)
  - [ ] Confirm schema.sql contains all required tables
  - [ ] Confirm PostgreSQL-compatible types used
  - [ ] Confirm foreign key constraints with CASCADE
  - [ ] Confirm all required indexes created
  - [ ] Confirm seed script works and is idempotent
  - [ ] Confirm validation script reports correctly
  - [ ] Run both scripts successfully

## Dev Notes

### Project Context
This is the **third story** in Epic 1 (Foundation & Shared Configuration). The tenant metadata database is required for Story 1.5 (FastAPI) to query tenants, users, and dashboard assignments. The mock data in this story MUST align with mock_users.py from Story 1.2.

### Previous Story Insights
Story 1.2 defined mock users with specific UUIDs and tenant mappings. This story MUST use identical UUIDs and mappings to ensure consistency between JWT tokens and database records.

### Complete Database Schema
[Source: architecture/8-database-schema.md]

The complete schema is provided in the architecture document. Key highlights:

**Tables:**
1. `tenants` - Tenant organizations with config_json for branding
2. `users` - Authenticated users (sub from JWT)
3. `user_tenants` - Junction table for user-tenant access with roles
4. `dashboards` - Dashboard definitions
5. `tenant_dashboards` - Junction table for tenant-dashboard assignments

**PostgreSQL Compatibility Notes:**
- UUIDs stored as TEXT (PostgreSQL: UUID type)
- Booleans as INTEGER 0/1 (PostgreSQL: BOOLEAN type)
- JSON as TEXT (PostgreSQL: JSONB type)
- Timestamps as TEXT ISO 8601 (PostgreSQL: TIMESTAMPTZ)

### Mock Tenant Data
[Source: architecture/8-database-schema.md]

**Tenant 1: Acme Corporation**
- ID: `8e1b3d5b-7c9a-4e2f-b1d3-a5c7e9f12345`
- Slug: `acme-corp`
- Branding: Logo `/logos/acme.svg`, Primary Color `#0052cc`
- Features: `show_experimental: false`
- Dashboards: Both (customer-lifetime-value, risk-analysis)

**Tenant 2: Beta Industries**
- ID: `2450a2f8-3b7e-4eab-9b4a-1f73d9a0b1c4`
- Slug: `beta-ind`
- Branding: Logo `/logos/beta.svg`, Primary Color `#ff5722`
- Features: `show_experimental: true`
- Dashboards: Only risk-analysis

### Mock User Data (MUST MATCH Story 1.2)
[Source: architecture/8-database-schema.md + packages/shared-config/mock_users.py]

**User 1: Analyst (Single Tenant - Acme Viewer)**
- user_id: `f8d1e2c3-4b5a-6789-abcd-ef1234567890`
- email: `analyst@acme.com`
- Tenant access: Acme only (viewer role)

**User 2: Admin (Multi-Tenant - Admin Both)**
- user_id: `a1b2c3d4-e5f6-7890-abcd-ef1234567890`
- email: `admin@acme.com`
- Tenant access: Acme (admin), Beta (admin)

**User 3: Viewer (Single Tenant - Beta Viewer)**
- user_id: `b2c3d4e5-f6a7-8901-bcde-f12345678901`
- email: `viewer@beta.com`
- Tenant access: Beta only (viewer role)

### Dashboard Definitions
[Source: architecture/8-database-schema.md]

**Dashboard 1: Customer Lifetime Value**
- slug: `customer-lifetime-value`
- title: `Customer Lifetime Value`
- description: `Analyze customer lifetime value metrics and segmentation`
- config_json: `{"layout": "grid", "thresholds": {"high": 15000, "medium": 8000}, "labels": {"currency": "USD"}}`

**Dashboard 2: Risk Analysis**
- slug: `risk-analysis`
- title: `Risk Analysis`
- description: `Risk scoring and exposure analysis dashboards`
- config_json: `{"layout": "single", "thresholds": {"critical": 0.8, "warning": 0.5}, "labels": {"unit": "probability"}}`

### Seed Script Implementation Pattern
[Source: prd/epic-1 AC #5, #11]

**scripts/seed-database.py:**
```python
#!/usr/bin/env python3
"""
Seed the tenant metadata database with mock data.
Idempotent: Drops and recreates database on each run.
"""
import sqlite3
import os
from pathlib import Path

# Paths
PROJECT_ROOT = Path(__file__).parent.parent
DB_PATH = PROJECT_ROOT / "data" / "tenant_metadata.db"
SCHEMA_PATH = PROJECT_ROOT / "database" / "schema.sql"

def seed_database():
    """Create and seed the tenant metadata database."""
    # Ensure data directory exists
    DB_PATH.parent.mkdir(exist_ok=True)

    # Remove existing database for idempotency
    if DB_PATH.exists():
        print(f"Removing existing database: {DB_PATH}")
        DB_PATH.unlink()

    # Create and seed database
    print(f"Creating database: {DB_PATH}")
    conn = sqlite3.connect(DB_PATH)

    try:
        # Read and execute schema
        with open(SCHEMA_PATH, 'r') as f:
            schema_sql = f.read()

        conn.executescript(schema_sql)
        conn.commit()

        # Verify records created
        cursor = conn.cursor()
        tables = ['tenants', 'users', 'user_tenants', 'dashboards', 'tenant_dashboards']

        print("\n✓ Database seeded successfully!")
        print("\nRecord counts:")
        for table in tables:
            count = cursor.execute(f"SELECT COUNT(*) FROM {table}").fetchone()[0]
            print(f"  {table}: {count}")

    except Exception as e:
        print(f"✗ Error seeding database: {e}")
        raise
    finally:
        conn.close()

if __name__ == "__main__":
    seed_database()
```

### Validation Script Implementation
[Source: prd/epic-1 AC #10]

**scripts/validate-database.py:**
```python
#!/usr/bin/env python3
"""
Validate the tenant metadata database structure and seed data.
"""
import sqlite3
import sys
from pathlib import Path

PROJECT_ROOT = Path(__file__).parent.parent
DB_PATH = PROJECT_ROOT / "data" / "tenant_metadata.db"

def validate_database():
    """Validate database structure and seed data."""
    if not DB_PATH.exists():
        print(f"✗ Database not found: {DB_PATH}")
        print("  Run: python scripts/seed-database.py")
        return False

    conn = sqlite3.connect(DB_PATH)
    cursor = conn.cursor()

    checks_passed = True

    try:
        # Check tenants
        tenants = cursor.execute("SELECT name, slug FROM tenants ORDER BY name").fetchall()
        if len(tenants) != 2:
            print(f"✗ Expected 2 tenants, found {len(tenants)}")
            checks_passed = False
        else:
            print(f"✓ Tenants: {tenants}")

        # Check users
        users = cursor.execute("SELECT email FROM users ORDER BY email").fetchall()
        if len(users) != 3:
            print(f"✗ Expected 3 users, found {len(users)}")
            checks_passed = False
        else:
            print(f"✓ Users: {[u[0] for u in users]}")

        # Check user_tenants mappings
        mappings = cursor.execute("SELECT COUNT(*) FROM user_tenants").fetchone()[0]
        if mappings != 4:
            print(f"✗ Expected 4 user_tenants mappings, found {mappings}")
            checks_passed = False
        else:
            print(f"✓ User-tenant mappings: {mappings}")

        # Check dashboards
        dashboards = cursor.execute("SELECT slug, title FROM dashboards ORDER BY slug").fetchall()
        if len(dashboards) != 2:
            print(f"✗ Expected 2 dashboards, found {len(dashboards)}")
            checks_passed = False
        else:
            print(f"✓ Dashboards: {[d[0] for d in dashboards]}")

        # Check tenant_dashboards
        td = cursor.execute("SELECT COUNT(*) FROM tenant_dashboards").fetchone()[0]
        if td != 3:
            print(f"✗ Expected 3 tenant_dashboards, found {td}")
            checks_passed = False
        else:
            print(f"✓ Tenant-dashboard assignments: {td}")

    except Exception as e:
        print(f"✗ Error validating database: {e}")
        checks_passed = False
    finally:
        conn.close()

    if checks_passed:
        print("\n✓ Database validation passed!")
        return True
    else:
        print("\n✗ Database validation failed!")
        return False

if __name__ == "__main__":
    success = validate_database()
    sys.exit(0 if success else 1)
```

### Foreign Key Constraints
[Source: architecture/8-database-schema.md AC #3]

All junction tables MUST define ON DELETE CASCADE:

```sql
FOREIGN KEY (user_id) REFERENCES users(user_id) ON DELETE CASCADE,
FOREIGN KEY (tenant_id) REFERENCES tenants(id) ON DELETE CASCADE
```

This ensures:
- Deleting a tenant removes all user_tenants and tenant_dashboards entries
- Deleting a user removes all user_tenants entries
- No orphaned records in junction tables

### PostgreSQL Migration Notes
[Source: architecture/8-database-schema.md#8.2]

Document in schema.sql comments:

```sql
-- ============================================================================
-- PostgreSQL Migration Notes (MVP)
-- ============================================================================
-- 1. Change TEXT UUIDs to native UUID type
-- 2. Change INTEGER booleans to BOOLEAN type
-- 3. Change TEXT timestamps to TIMESTAMPTZ
-- 4. Change TEXT JSON to JSONB
-- 5. Add GIN indexes on JSONB columns
-- 6. Enable Row-Level Security (RLS)
-- 7. Create RLS policies for multi-tenant isolation
-- See: docs/architecture/8-database-schema.md#8.2 for migration SQL
```

### Testing
[Source: architecture/15-testing-strategy.md]

**No automated unit tests required** - validation script serves as integration test.

**Manual validation:**
1. Run seed script: `python scripts/seed-database.py`
2. Verify database file created: `ls -lh data/tenant_metadata.db`
3. Run validation script: `python scripts/validate-database.py`
4. Verify all checks pass
5. Test idempotency: Run seed script again, validate again
6. Inspect database: `sqlite3 data/tenant_metadata.db "SELECT * FROM tenants;"`

**Definition of Done:**
- schema.sql contains all tables with PostgreSQL-compatible types
- All foreign keys and indexes defined
- Seed data matches shared-config mock users
- seed-database.py script works and is idempotent
- validate-database.py script reports all checks pass
- Documentation added to README
- All acceptance criteria met

## Change Log
| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-10-11 | 0.1 | Initial story creation from Epic 1 | James (Dev Agent) |

## Dev Agent Record

### Agent Model Used
_(To be filled during implementation)_

### Debug Log References
_(To be filled during implementation)_

### Completion Notes List
_(To be filled during implementation)_

### File List
**Created:**
_(To be filled during implementation)_

**Modified:**
_(To be filled during implementation)_

## QA Results
_(To be filled by QA Agent)_
