# Story 2.3: Token Exchange Endpoint for Tenant Scoping

## Status
Ready for Review

## Story
**As a** user,
**I want** to exchange my user access token for a tenant-scoped token after selecting a tenant,
**so that** I can access dashboards and data specific to that tenant with hard isolation.

## Acceptance Criteria
1. POST /api/token/exchange endpoint requires Bearer token (user access token) and accepts {tenant_id: string} in request body
2. Endpoint validates user access token and extracts tenant_ids array from claims
3. Endpoint verifies requested tenant_id is in the user's tenant_ids array, returns 403 "ACCESS_DENIED" if not
4. Endpoint queries user_tenants table to get user's role for the requested tenant
5. Endpoint generates tenant-scoped JWT with claims: sub (user_id), email, tenant_id (single UUID), role, iat, exp (30 minutes)
6. Tenant-scoped JWT signed with shared JWT_SECRET_KEY using HS256 algorithm
7. Response returns {access_token: string, token_type: "Bearer", expires_in: 1800}
8. If tenant_id missing from request, returns 400 "INVALID_REQUEST"
9. If user does not have access to tenant, returns 403 with error: {error: {code: "TENANT_ACCESS_DENIED", message: "User does not have access to tenant ..."}}
10. Endpoint logs token exchange: user_id, tenant_id, role, token expiry
11. Unit tests verify tenant_id validation and JWT claims structure
12. Integration test verifies complete exchange flow and validates resulting tenant-scoped token
13. Security test verifies user cannot exchange token for unauthorized tenant

## Tasks / Subtasks

- [x] **Task 1: Create token exchange endpoint** (AC: 1, 7, 8, 10)
  - [ ] Create `apps/api/src/routers/token.py` with APIRouter instance
  - [ ] Import `get_current_user` middleware from middleware/auth.py
  - [ ] Define POST `/api/token/exchange` endpoint handler
  - [ ] Add `get_current_user` dependency to extract user claims
  - [ ] Create Pydantic request model: `TokenExchangeRequest(tenant_id: str)`
  - [ ] Create Pydantic response model: `TokenResponse(access_token: str, token_type: str, expires_in: int)`
  - [ ] Validate tenant_id is present in request, return 400 if missing
  - [ ] Add logging for token exchange with user_id, tenant_id, and role
  - [ ] Register token router in `main.py` with `/api/token` prefix

- [x] **Task 2: Implement tenant access validation** (AC: 2, 3, 9)
  - [ ] Extract tenant_ids array from user JWT claims
  - [ ] Verify requested tenant_id exists in tenant_ids array
  - [ ] If tenant_id not in array, raise 403 HTTPException with "TENANT_ACCESS_DENIED" error
  - [ ] Use standard error format with code, message, timestamp, request_id
  - [ ] Log access denial attempts for security monitoring
  - [ ] Handle edge cases: empty tenant_ids array, null tenant_id

- [x] **Task 3: Query user role for tenant** (AC: 4)
  - [ ] Create database query function: `get_user_tenant_role(user_id: str, tenant_id: str) -> str`
  - [ ] Add to `apps/api/src/database/queries.py`
  - [ ] SQL query: SELECT role FROM user_tenants WHERE user_id = ? AND tenant_id = ?
  - [ ] Handle case where no role found (should not happen if validation passed)
  - [ ] Return role string ('admin', 'viewer', etc.)
  - [ ] Test query with mock data for all user/tenant combinations

- [x] **Task 4: Generate tenant-scoped JWT** (AC: 5, 6)
  - [ ] Import `encode_tenant_token`, `TENANT_TOKEN_EXPIRY` from shared_config
  - [ ] Extract user data: user_id (sub), email from user token claims
  - [ ] Construct tenant token payload: sub, email, tenant_id (single UUID), role
  - [ ] Set exp claim to current timestamp + 1800 seconds (30 minutes)
  - [ ] Set iat claim to current timestamp
  - [ ] Set iss claim to JWT_ISSUER ("kyros-poc")
  - [ ] Call `encode_tenant_token()` to generate signed JWT
  - [ ] Return TokenResponse with access_token, token_type="Bearer", expires_in=1800

- [x] **Task 5: Integrate role query with token generation** (AC: 4, 5, 10)
  - [ ] Call `get_user_tenant_role()` with user_id and tenant_id
  - [ ] Pass role to token generation function
  - [ ] Include role in JWT claims
  - [ ] Log complete token exchange details (user_id, tenant_id, role, expiry)
  - [ ] Handle database errors gracefully with 500 response

- [x] **Task 6: Write unit tests for access validation** (AC: 11, 13)
  - [ ] Create `apps/api/tests/test_token_exchange.py`
  - [ ] Test tenant_id in user's tenant_ids array (should succeed)
  - [ ] Test tenant_id NOT in user's tenant_ids array (should return 403)
  - [ ] Test with empty tenant_ids array (should return 403)
  - [ ] Test with missing tenant_id in request (should return 400)
  - [ ] Test error response format matches standard
  - [ ] Verify "TENANT_ACCESS_DENIED" error code

- [x] **Task 7: Write unit tests for JWT generation** (AC: 11)
  - [ ] Test tenant-scoped JWT claims structure
  - [ ] Verify tenant_id is single UUID (not array)
  - [ ] Verify role is included in claims
  - [ ] Verify exp is 30 minutes from iat (1800 seconds)
  - [ ] Verify JWT signature with JWT_SECRET_KEY
  - [ ] Test token_type is "Bearer"
  - [ ] Test expires_in is 1800

- [x] **Task 8: Write integration test for complete exchange flow** (AC: 12)
  - [ ] Generate user access token with multiple tenant_ids
  - [ ] Call POST /api/token/exchange with valid tenant_id
  - [ ] Verify 200 response with tenant-scoped token
  - [ ] Decode tenant-scoped token and verify claims
  - [ ] Test exchange for analyst@acme.com -> Acme tenant (viewer role)
  - [ ] Test exchange for admin@acme.com -> Acme tenant (admin role)
  - [ ] Test exchange for admin@acme.com -> Beta tenant (admin role)
  - [ ] Verify resulting token can be validated with validate_tenant_token()

- [x] **Task 9: Write security test for unauthorized access** (AC: 13)
  - [ ] Create user token with tenant_ids: ["acme-uuid"]
  - [ ] Attempt token exchange for beta-uuid (unauthorized)
  - [ ] Verify 403 response with "TENANT_ACCESS_DENIED" error
  - [ ] Test viewer@beta.com cannot exchange for Acme tenant
  - [ ] Test analyst@acme.com cannot exchange for Beta tenant
  - [ ] Verify security logs capture unauthorized attempts

- [x] **Task 10: Add API documentation** (AC: 10)
  - [ ] Add OpenAPI docstring to /api/token/exchange endpoint
  - [ ] Document request body schema and required fields
  - [ ] Document response schema for success (200)
  - [ ] Document error responses (400, 401, 403, 500)
  - [ ] Add examples with analyst@acme.com exchanging for Acme tenant
  - [ ] Tag endpoint as "Token Exchange" in Swagger UI
  - [ ] Add security requirement for Bearer token
  - [ ] Document that this is the core PoC validation mechanism

## Dev Notes

### Project Context
This is the **third story** in Epic 2 (Mock Authentication & Token Exchange) and represents **the core architectural pattern being validated in this PoC** - converting multi-tenant user tokens into single-tenant scoped tokens for hard data isolation.

### Previous Story Insights
- Story 2.1: Generates user access tokens with tenant_ids array
- Story 2.2: Provides tenant list for user to select from
- This story: Converts selection into tenant-scoped token for isolated access

### Architecture References

**API Specification** [Source: architecture/5-api-specification.md]

Endpoint contract:
```
POST /api/token/exchange
Headers: Authorization: Bearer <user_access_token>
Request:  { "tenant_id": "acme-corp-uuid" }
Response: {
  "access_token": "eyJ...",  // tenant-scoped JWT
  "token_type": "Bearer",
  "expires_in": 1800
}
```

Error responses:
- 400: Missing tenant_id in request
- 401: Invalid/expired user token
- 403: User does not have access to requested tenant

**Token Comparison**

User Access Token (input):
```json
{
  "sub": "user-uuid",
  "email": "admin@acme.com",
  "tenant_ids": ["acme-uuid", "beta-uuid"],  // ARRAY
  "iat": 1234567890,
  "exp": 1234571490,  // 1 hour
  "iss": "kyros-poc"
}
```

Tenant-Scoped Token (output):
```json
{
  "sub": "user-uuid",
  "email": "admin@acme.com",
  "tenant_id": "acme-uuid",  // SINGLE VALUE
  "role": "admin",           // NEW: user's role for this tenant
  "iat": 1234567890,
  "exp": 1234569690,  // 30 minutes (shorter lifetime)
  "iss": "kyros-poc"
}
```

**Backend Architecture** [Source: architecture/10-backend-architecture.md]

File structure:
- Router: `apps/api/src/routers/token.py`
- Queries: `apps/api/src/database/queries.py` (add get_user_tenant_role)
- Middleware: Reuse `apps/api/src/middleware/auth.py` (get_current_user)

**JWT Token Generation** [Source: Epic 1 Story 1.2, shared_config module]

Import tenant token utilities:
```python
from shared_config import (
    encode_tenant_token,
    TENANT_TOKEN_EXPIRY,  # 1800 seconds
    JWT_SECRET_KEY,
    JWT_ALGORITHM
)

# Generate tenant-scoped token
token = encode_tenant_token(
    user_id=user_id,
    email=email,
    tenant_id=tenant_id,  # Single UUID
    role=role
)
```

**Database Schema** [Source: architecture/8-database-schema.md]

user_tenants table query:
```sql
SELECT role
FROM user_tenants
WHERE user_id = ?
  AND tenant_id = ?
```

Expected roles:
- 'admin': Full access to tenant resources
- 'viewer': Read-only access to tenant resources

**Access Control Logic**

Critical security check:
```python
# Extract from user token
user_tenant_ids = user_claims.get("tenant_ids", [])

# Validate access
if requested_tenant_id not in user_tenant_ids:
    raise HTTPException(
        status_code=403,
        detail={
            "error": {
                "code": "TENANT_ACCESS_DENIED",
                "message": f"User does not have access to tenant {requested_tenant_id}",
                "timestamp": datetime.utcnow().isoformat(),
                "request_id": str(uuid.uuid4())
            }
        }
    )
```

**Error Handling** [Source: architecture/17-error-handling-strategy.md]

Error response examples:

400 Missing tenant_id:
```python
raise HTTPException(
    status_code=400,
    detail={
        "error": {
            "code": "INVALID_REQUEST",
            "message": "tenant_id is required",
            "timestamp": datetime.utcnow().isoformat(),
            "request_id": str(uuid.uuid4())
        }
    }
)
```

403 Access denied:
```python
raise HTTPException(
    status_code=403,
    detail={
        "error": {
            "code": "TENANT_ACCESS_DENIED",
            "message": f"User {user_id} does not have access to tenant {tenant_id}",
            "timestamp": datetime.utcnow().isoformat(),
            "request_id": str(uuid.uuid4())
        }
    }
)
```

**Logging** [Source: architecture/18-monitoring-and-observability.md]

Log token exchanges for audit trail:
```python
logger.info(
    "Token exchange successful",
    extra={
        "user_id": user_id,
        "email": email,
        "tenant_id": tenant_id,
        "role": role,
        "token_expires_at": (datetime.utcnow() + timedelta(seconds=1800)).isoformat(),
        "timestamp": datetime.utcnow().isoformat()
    }
)
```

Log access denials:
```python
logger.warning(
    "Token exchange denied - unauthorized tenant",
    extra={
        "user_id": user_id,
        "email": email,
        "requested_tenant_id": tenant_id,
        "user_tenant_ids": user_tenant_ids,
        "timestamp": datetime.utcnow().isoformat()
    }
)
```

### Testing

**Test Framework:** pytest with FastAPI TestClient

**Test Location:** `apps/api/tests/test_token_exchange.py`

**Test Standards** [Source: architecture/15-testing-strategy.md]

Unit test requirements:
1. Tenant access validation (authorized/unauthorized)
2. JWT claims structure and content
3. Role retrieval from database
4. Token expiry calculation (1800 seconds)
5. Error handling (400, 403)

Integration test requirements:
1. Full exchange flow with real database
2. Test all user/tenant combinations from mock data
3. Verify resulting token structure
4. Validate token with validate_tenant_token()

Security test requirements:
1. Cross-tenant access prevention
2. Verify analyst@acme.com cannot access Beta
3. Verify viewer@beta.com cannot access Acme
4. Verify admin@acme.com CAN access both (has both tenant_ids)

**Mock Data Test Scenarios:**

| User | User Tenant IDs | Exchange For | Expected Result |
|------|----------------|--------------|-----------------|
| analyst@acme.com | [acme] | acme | ✅ Success (role: viewer) |
| analyst@acme.com | [acme] | beta | ❌ 403 TENANT_ACCESS_DENIED |
| admin@acme.com | [acme, beta] | acme | ✅ Success (role: admin) |
| admin@acme.com | [acme, beta] | beta | ✅ Success (role: admin) |
| viewer@beta.com | [beta] | beta | ✅ Success (role: viewer) |
| viewer@beta.com | [beta] | acme | ❌ 403 TENANT_ACCESS_DENIED |

**Test Pattern:**
```python
def test_token_exchange_authorized(client):
    # Generate user token with multiple tenants
    from shared_config import encode_user_token
    user_token = encode_user_token(
        user_id="admin-uuid",
        email="admin@acme.com",
        tenant_ids=["acme-uuid", "beta-uuid"]
    )

    # Exchange for Acme tenant
    response = client.post(
        "/api/token/exchange",
        json={"tenant_id": "acme-uuid"},
        headers={"Authorization": f"Bearer {user_token}"}
    )

    # Verify success
    assert response.status_code == 200
    data = response.json()
    assert data["token_type"] == "Bearer"
    assert data["expires_in"] == 1800

    # Decode tenant token
    from shared_config import validate_tenant_token
    tenant_token_payload = validate_tenant_token(data["access_token"])
    assert tenant_token_payload["tenant_id"] == "acme-uuid"
    assert tenant_token_payload["role"] == "admin"
```

### Dependencies
- **Depends on:** Story 2.1 (Mock Authentication) - generates user tokens
- **Depends on:** Story 2.2 (User Info) - JWT middleware pattern
- **Depends on:** Epic 1 Story 1.2 (Shared Config) - encode_tenant_token
- **Depends on:** Epic 1 Story 1.3 (Database) - user_tenants table
- **Blocks:** Story 2.4 (Tenant Metadata API) - provides tenant-scoped tokens
- **Blocks:** Epic 3+ - All subsequent features require tenant-scoped tokens

### Security Considerations

**Critical Security Checks:**
1. ✅ Validate user token before processing
2. ✅ Verify tenant_id is in user's authorized tenant_ids array
3. ✅ Query user_tenants table for role (don't trust JWT claims)
4. ✅ Short token lifetime (30 minutes) reduces exposure window
5. ✅ Log all exchange attempts for security audit

**PoC Simplifications:**
- Single JWT secret (MVP should use key rotation)
- No token revocation mechanism (MVP needs Redis-backed blacklist)
- No rate limiting (MVP should limit exchange frequency per user)

**MVP Migration Notes:**
- Add token refresh mechanism
- Implement JWT key rotation
- Add Redis for token blacklist/revocation
- Add rate limiting per user
- Consider separate signing keys for user vs tenant tokens

## Change Log
| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-10-12 | 0.1 | Initial story creation from Epic 2 | Sarah (PO Agent) |
| 2025-10-12 | 1.0 | Story implementation completed | James (Dev Agent) |

## Dev Agent Record

### Agent Model Used
Claude 3.5 Sonnet (claude-sonnet-4-5-20250929)

### Debug Log References
None - implementation followed established patterns from Stories 2.1 and 2.2

### Completion Notes List
- Created token exchange endpoint at apps/api/src/routers/token.py with POST /api/token/exchange
- Implemented tenant access validation: verifies tenant_id is in user's tenant_ids array
- Added database query function get_user_tenant_role() in apps/api/src/database/queries.py
- Query fetches user's role for specific tenant from user_tenants table
- Generates tenant-scoped JWT with single tenant_id (not array) using encode_tenant_token()
- Tenant token includes: sub, email, tenant_id (single UUID), role, iat, exp (1800s), iss
- Token lifetime: 30 minutes (1800 seconds) vs 1 hour for user tokens
- Added comprehensive error handling: 400 (missing tenant_id), 403 (unauthorized access), 500 (database errors)
- Standardized error responses with code, message, timestamp, request_id
- Logging for successful exchanges and unauthorized access attempts
- Created Pydantic models: TokenExchangeRequest and reused TokenResponse
- Registered token router in main.py with /api/token prefix
- Wrote unit tests in apps/api/tests/test_token_exchange.py (14 test cases)
- Wrote integration and security tests in apps/api/tests/test_token_exchange_integration.py (12 test cases)
- Tested successfully with all 3 mock users:
  - analyst@acme.com can exchange for Acme (viewer role) ✅
  - analyst@acme.com CANNOT exchange for Beta (403 denied) ✅
  - admin@acme.com can exchange for both Acme and Beta (admin role) ✅
  - viewer@beta.com can exchange for Beta (viewer role) ✅
  - viewer@beta.com CANNOT exchange for Acme (403 denied) ✅
- Verified tenant-scoped tokens have correct claims structure with single tenant_id
- Verified role is fetched from database, not from JWT claims (security best practice)

### File List
**Created:**
- `apps/api/src/routers/token.py` - Token exchange router with POST /api/token/exchange endpoint
- `apps/api/tests/test_token_exchange.py` - Unit tests for access validation and JWT generation (14 tests)
- `apps/api/tests/test_token_exchange_integration.py` - Integration and security tests (12 tests)

**Modified:**
- `apps/api/src/models/tokens.py` - Added TokenExchangeRequest model
- `apps/api/src/models/__init__.py` - Added TokenExchangeRequest export
- `apps/api/src/database/queries.py` - Added get_user_tenant_role() function
- `apps/api/src/main.py` - Added token router import and registration

## QA Results
_(To be filled by QA Agent)_
