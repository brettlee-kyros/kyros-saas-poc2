# Story 1.5: FastAPI Health Check and Basic Setup

## Status
Ready for Review

## Story
**As a** developer,
**I want** a basic FastAPI application with health check endpoint and database connectivity,
**so that** I can verify the API service is running and can access the tenant metadata database.

## Acceptance Criteria
1. apps/api/src/main.py created with FastAPI app initialization
2. GET /health endpoint returns {"status": "ok", "timestamp": "<ISO 8601>"} with 200 status
3. FastAPI app configured with CORS middleware allowing requests from localhost:3000 (Shell UI origin)
4. apps/api/src/database/connection.py provides async SQLite connection function using aiosqlite
5. GET /health/db endpoint queries database (SELECT COUNT(*) FROM tenants) and returns database health status
6. FastAPI application loads shared_config module successfully and logs JWT configuration on startup
7. Startup logging confirms: database path, shared config loaded, listening port
8. All endpoints use consistent JSON error response format matching architecture document (error.code, error.message, error.timestamp, error.request_id)
9. FastAPI auto-generated docs available at http://localhost:8000/docs (Swagger UI)
10. Health check endpoints accessible via curl from host machine and from other Docker containers

## Tasks / Subtasks
- [ ] **Task 1: Create FastAPI application structure** (AC: 1)
  - [ ] Create `apps/api/src/` directory
  - [ ] Create `apps/api/src/__init__.py`
  - [ ] Create `apps/api/src/main.py` with FastAPI app initialization
  - [ ] Configure FastAPI app with title, description, version
  - [ ] Enable automatic OpenAPI docs at /docs
  - [ ] Add startup event handler for logging

- [ ] **Task 2: Configure CORS middleware** (AC: 3)
  - [ ] Import CORSMiddleware from fastapi.middleware.cors
  - [ ] Add CORS middleware to FastAPI app
  - [ ] Allow origin: http://localhost:3000 (Shell UI)
  - [ ] Allow credentials: True
  - [ ] Allow methods: ["GET", "POST", "PUT", "DELETE", "OPTIONS"]
  - [ ] Allow headers: ["*"]
  - [ ] Document CORS configuration in comments

- [ ] **Task 3: Create database connection module** (AC: 4)
  - [ ] Create `apps/api/src/database/` directory
  - [ ] Create `apps/api/src/database/__init__.py`
  - [ ] Create `apps/api/src/database/connection.py`
  - [ ] Implement `get_db_connection()` async function using aiosqlite
  - [ ] Read DATABASE_PATH from environment variable
  - [ ] Add connection error handling
  - [ ] Add connection pooling or connection manager pattern

- [ ] **Task 4: Implement /health endpoint** (AC: 2, 8)
  - [ ] Create `apps/api/src/routers/` directory
  - [ ] Create `apps/api/src/routers/__init__.py`
  - [ ] Create `apps/api/src/routers/health.py`
  - [ ] Implement GET /health endpoint returning status and timestamp
  - [ ] Use ISO 8601 format for timestamp
  - [ ] Include endpoint in main.py router
  - [ ] Add OpenAPI documentation tags

- [ ] **Task 5: Implement /health/db endpoint** (AC: 5, 8)
  - [ ] Add GET /health/db endpoint to health router
  - [ ] Query database: SELECT COUNT(*) FROM tenants
  - [ ] Return tenant count and database status
  - [ ] Handle database connection errors gracefully
  - [ ] Return appropriate error response if database unavailable
  - [ ] Log database health check results

- [ ] **Task 6: Create error response models** (AC: 8)
  - [ ] Create `apps/api/src/models/` directory
  - [ ] Create `apps/api/src/models/__init__.py`
  - [ ] Create `apps/api/src/models/errors.py`
  - [ ] Define Pydantic ErrorDetail model matching architecture spec
  - [ ] Define ApiErrorResponse model with error.code, message, timestamp, request_id
  - [ ] Create utility function to generate request_id (UUID)
  - [ ] Export models for use in error handlers

- [ ] **Task 7: Implement global exception handler** (AC: 8)
  - [ ] Create exception handler for generic Exception
  - [ ] Create exception handler for HTTPException
  - [ ] Create exception handler for database errors
  - [ ] Format all errors using ApiErrorResponse model
  - [ ] Generate unique request_id for each error
  - [ ] Log errors with request_id for correlation
  - [ ] Register exception handlers in main.py

- [ ] **Task 8: Load and verify shared_config on startup** (AC: 6, 7)
  - [ ] Import shared_config module in main.py
  - [ ] Create startup event handler
  - [ ] Log JWT configuration loaded (algorithm, expiry times)
  - [ ] Verify JWT_SECRET_KEY is accessible
  - [ ] Log database path from environment
  - [ ] Log listening port and host
  - [ ] Add error handling for missing shared_config

- [ ] **Task 9: Create configuration module** (AC: 6, 7)
  - [ ] Create `apps/api/src/config/` directory
  - [ ] Create `apps/api/src/config/__init__.py`
  - [ ] Create `apps/api/src/config/settings.py`
  - [ ] Use pydantic BaseSettings for configuration
  - [ ] Define DATABASE_PATH setting (from env)
  - [ ] Define HOST and PORT settings
  - [ ] Define CORS_ORIGINS setting
  - [ ] Load shared_config JWT settings

- [ ] **Task 10: Test health endpoints** (AC: 2, 5, 10)
  - [ ] Start FastAPI dev server: `uvicorn src.main:app --reload`
  - [ ] Test GET /health with curl: `curl http://localhost:8000/health`
  - [ ] Verify response format: {"status": "ok", "timestamp": "..."}
  - [ ] Test GET /health/db with curl
  - [ ] Verify tenant count returned
  - [ ] Test from Docker container: `docker exec kyros-api curl http://localhost:8000/health`

- [ ] **Task 11: Verify OpenAPI documentation** (AC: 9)
  - [ ] Access Swagger UI at http://localhost:8000/docs
  - [ ] Verify all endpoints listed with proper descriptions
  - [ ] Verify request/response schemas documented
  - [ ] Test endpoints directly from Swagger UI
  - [ ] Verify error response schemas visible

- [ ] **Task 12: Write unit tests** (AC: 2, 5, 8)
  - [ ] Create `apps/api/tests/` directory
  - [ ] Create `apps/api/tests/__init__.py`
  - [ ] Create `apps/api/tests/test_health.py`
  - [ ] Test GET /health returns 200 with correct format
  - [ ] Test GET /health/db returns tenant count
  - [ ] Test error response format
  - [ ] Use pytest and httpx for async tests
  - [ ] Run tests: `pytest apps/api/tests/ -v`

- [ ] **Task 13: Verify all acceptance criteria** (AC: 1-10)
  - [ ] Confirm main.py created and FastAPI initialized
  - [ ] Confirm /health endpoint works
  - [ ] Confirm CORS configured correctly
  - [ ] Confirm database connection works
  - [ ] Confirm /health/db queries database
  - [ ] Confirm shared_config loaded
  - [ ] Confirm startup logging complete
  - [ ] Confirm error response format correct
  - [ ] Confirm Swagger docs accessible
  - [ ] Confirm endpoints accessible from Docker

## Dev Notes

### Project Context
This is the **fifth story** in Epic 1 (Foundation & Shared Configuration). This story creates the foundational FastAPI application structure that will be extended in Epic 2 (Auth & Token Exchange) and Epic 3 (Data Access). The health check endpoints provide a way to verify the service is operational.

### Previous Story Insights
- Story 1.2: Created shared-config package with JWT configuration
- Story 1.3: Created database at data/tenant_metadata.db
- Story 1.4: Configured Docker Compose to run API service on port 8000

This story integrates all these components into a working FastAPI application.

### FastAPI Application Structure
[Source: architecture/10-backend-architecture.md]

```
apps/api/src/
├── main.py                       # FastAPI app entry point ⭐ THIS STORY
├── config/
│   ├── __init__.py
│   └── settings.py               # Environment configuration ⭐ THIS STORY
├── middleware/
│   ├── __init__.py
│   ├── auth.py                   # JWT validation middleware (Epic 2)
│   └── cors.py                   # CORS configuration ⭐ THIS STORY
├── routers/
│   ├── __init__.py
│   ├── health.py                 # Health check endpoints ⭐ THIS STORY
│   ├── auth.py                   # Mock auth endpoints (Epic 2)
│   ├── token.py                  # Token exchange endpoints (Epic 2)
│   ├── tenant.py                 # Tenant metadata endpoints (Epic 2)
│   └── dashboard.py              # Dashboard data endpoints (Epic 3)
├── models/
│   ├── __init__.py
│   ├── errors.py                 # Error response models ⭐ THIS STORY
│   ├── tokens.py                 # Pydantic models for JWTs (Epic 2)
│   ├── tenant.py                 # Tenant data models (Epic 2)
│   └── dashboard.py              # Dashboard data models (Epic 3)
├── services/
│   ├── __init__.py
│   ├── jwt_service.py            # JWT encoding/decoding (Epic 2)
│   ├── tenant_service.py         # Tenant business logic (Epic 2)
│   └── data_service.py           # Dashboard data loading (Epic 3)
├── database/
│   ├── __init__.py
│   ├── connection.py             # SQLite async connection ⭐ THIS STORY
│   └── queries.py                # SQL query functions (Epic 2)
└── data/
    ├── __init__.py
    ├── mock_users.py             # Pre-generated JWTs (Epic 2)
    └── data_loader.py            # Pandas DataFrame loader (Epic 3)
```

### Main Application Entry Point
[Source: architecture/10-backend-architecture.md + prd/epic-1 AC #1, #3, #6]

**apps/api/src/main.py:**
```python
from fastapi import FastAPI
from fastapi.middleware.cors import CORSMiddleware
import logging
import os

from shared_config import JWT_SECRET_KEY, JWT_ALGORITHM, JWT_ISSUER
from src.config.settings import settings
from src.routers import health

# Configure logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

# Initialize FastAPI application
app = FastAPI(
    title="Kyros SaaS PoC API",
    description="FastAPI monolith for tenant-isolated dashboard platform",
    version="0.1.0",
    docs_url="/docs",
    redoc_url="/redoc"
)

# Configure CORS
app.add_middleware(
    CORSMiddleware,
    allow_origins=["http://localhost:3000"],  # Shell UI origin
    allow_credentials=True,
    allow_methods=["GET", "POST", "PUT", "DELETE", "OPTIONS"],
    allow_headers=["*"],
)

# Include routers
app.include_router(health.router, tags=["System"])

@app.on_event("startup")
async def startup_event():
    """Log configuration on application startup."""
    logger.info("=" * 80)
    logger.info("Kyros SaaS PoC API - Starting Up")
    logger.info("=" * 80)
    logger.info(f"Database path: {settings.DATABASE_PATH}")
    logger.info(f"Shared config loaded - JWT Algorithm: {JWT_ALGORITHM}")
    logger.info(f"Shared config loaded - JWT Issuer: {JWT_ISSUER}")
    logger.info(f"Listening on: {settings.HOST}:{settings.PORT}")
    logger.info(f"OpenAPI docs: http://{settings.HOST}:{settings.PORT}/docs")
    logger.info("=" * 80)
```

### Health Check Endpoints
[Source: architecture/5-api-specification.md + prd/epic-1 AC #2, #5]

**apps/api/src/routers/health.py:**
```python
from fastapi import APIRouter, HTTPException
from datetime import datetime
import logging

from src.database.connection import get_db_connection
from src.models.errors import ApiErrorResponse

router = APIRouter()
logger = logging.getLogger(__name__)

@router.get("/health")
async def health_check():
    """
    Basic health check endpoint.

    Returns:
        dict: Status and timestamp
    """
    return {
        "status": "ok",
        "timestamp": datetime.utcnow().isoformat() + "Z"
    }

@router.get("/health/db")
async def database_health_check():
    """
    Database health check endpoint.

    Returns:
        dict: Database status and tenant count
    """
    try:
        async with get_db_connection() as db:
            cursor = await db.execute("SELECT COUNT(*) FROM tenants")
            tenant_count = (await cursor.fetchone())[0]

        return {
            "status": "ok",
            "database": "connected",
            "tenant_count": tenant_count,
            "timestamp": datetime.utcnow().isoformat() + "Z"
        }
    except Exception as e:
        logger.error(f"Database health check failed: {e}")
        raise HTTPException(
            status_code=503,
            detail={
                "error": {
                    "code": "DATABASE_UNAVAILABLE",
                    "message": "Database connection failed",
                    "timestamp": datetime.utcnow().isoformat() + "Z"
                }
            }
        )
```

### Database Connection Module
[Source: architecture/3-tech-stack.md + prd/epic-1 AC #4]

**apps/api/src/database/connection.py:**
```python
import aiosqlite
from contextlib import asynccontextmanager
import logging

from src.config.settings import settings

logger = logging.getLogger(__name__)

@asynccontextmanager
async def get_db_connection():
    """
    Async context manager for SQLite database connections.

    Usage:
        async with get_db_connection() as db:
            cursor = await db.execute("SELECT * FROM tenants")
            results = await cursor.fetchall()

    Yields:
        aiosqlite.Connection: Database connection
    """
    conn = None
    try:
        conn = await aiosqlite.connect(settings.DATABASE_PATH)
        conn.row_factory = aiosqlite.Row  # Enable dict-like row access
        logger.debug(f"Database connection established: {settings.DATABASE_PATH}")
        yield conn
    except Exception as e:
        logger.error(f"Database connection error: {e}")
        raise
    finally:
        if conn:
            await conn.close()
            logger.debug("Database connection closed")
```

### Configuration Settings
[Source: architecture/16-coding-standards.md + prd/epic-1 AC #6, #7]

**apps/api/src/config/settings.py:**
```python
from pydantic_settings import BaseSettings
from typing import List
import os

class Settings(BaseSettings):
    """Application settings loaded from environment variables."""

    # Database configuration
    DATABASE_PATH: str = os.getenv("DATABASE_PATH", "/app/data/tenant_metadata.db")

    # Server configuration
    HOST: str = "0.0.0.0"
    PORT: int = 8000

    # CORS origins
    CORS_ORIGINS: List[str] = ["http://localhost:3000"]

    class Config:
        env_file = ".env"
        case_sensitive = True

settings = Settings()
```

### Error Response Models
[Source: architecture/17-error-handling-strategy.md + prd/epic-1 AC #8]

**apps/api/src/models/errors.py:**
```python
from pydantic import BaseModel, Field
from typing import Optional, Dict, Any
from datetime import datetime
import uuid

class ErrorDetail(BaseModel):
    """Standard error detail structure."""
    code: str = Field(..., description="Machine-readable error code")
    message: str = Field(..., description="Human-readable error message")
    details: Optional[Dict[str, Any]] = Field(None, description="Additional error context")
    timestamp: str = Field(..., description="ISO 8601 timestamp")
    request_id: str = Field(..., description="Unique request identifier for log correlation")

class ApiErrorResponse(BaseModel):
    """Standard API error response wrapper."""
    error: ErrorDetail

def generate_request_id() -> str:
    """Generate unique request ID."""
    return str(uuid.uuid4())

def create_error_response(
    code: str,
    message: str,
    details: Optional[Dict[str, Any]] = None
) -> Dict[str, Any]:
    """
    Create standardized error response.

    Args:
        code: Error code (e.g., "DATABASE_ERROR")
        message: Human-readable error message
        details: Optional additional error context

    Returns:
        dict: Formatted error response
    """
    return {
        "error": {
            "code": code,
            "message": message,
            "details": details,
            "timestamp": datetime.utcnow().isoformat() + "Z",
            "request_id": generate_request_id()
        }
    }
```

### CORS Configuration
[Source: architecture/5-api-specification.md + prd/epic-1 AC #3]

CORS middleware allows:
- **Origin:** http://localhost:3000 (Shell UI)
- **Credentials:** True (for cookie-based auth in future stories)
- **Methods:** GET, POST, PUT, DELETE, OPTIONS
- **Headers:** * (all headers allowed for PoC; restrict in MVP)

This allows Shell UI to make authenticated API calls from the browser.

### Testing Strategy
[Source: architecture/15-testing-strategy.md]

**Unit Tests Required:**

**apps/api/tests/test_health.py:**
```python
import pytest
from httpx import AsyncClient
from src.main import app

@pytest.mark.asyncio
async def test_health_endpoint():
    """Test /health endpoint returns 200 with correct format."""
    async with AsyncClient(app=app, base_url="http://test") as client:
        response = await client.get("/health")

    assert response.status_code == 200
    data = response.json()
    assert data["status"] == "ok"
    assert "timestamp" in data

@pytest.mark.asyncio
async def test_database_health_endpoint():
    """Test /health/db endpoint queries database."""
    async with AsyncClient(app=app, base_url="http://test") as client:
        response = await client.get("/health/db")

    assert response.status_code == 200
    data = response.json()
    assert data["status"] == "ok"
    assert data["database"] == "connected"
    assert "tenant_count" in data
    assert data["tenant_count"] >= 0  # Should be 2 from seed data
```

**Test execution:**
```bash
cd apps/api
pytest tests/ -v
```

### Startup Logging Requirements
[Source: prd/epic-1 AC #7]

On startup, FastAPI must log:
1. Database path being used
2. Shared config loaded confirmation
3. JWT algorithm and issuer
4. Host and port listening
5. OpenAPI docs URL

Example output:
```
================================================================================
Kyros SaaS PoC API - Starting Up
================================================================================
Database path: /app/data/tenant_metadata.db
Shared config loaded - JWT Algorithm: HS256
Shared config loaded - JWT Issuer: kyros-poc
Listening on: 0.0.0.0:8000
OpenAPI docs: http://0.0.0.0:8000/docs
================================================================================
```

### OpenAPI Documentation
[Source: prd/epic-1 AC #9]

FastAPI automatically generates:
- **Swagger UI:** http://localhost:8000/docs
- **ReDoc:** http://localhost:8000/redoc
- **OpenAPI JSON:** http://localhost:8000/openapi.json

All endpoints must include:
- Summary and description
- Request/response schemas
- Error response examples
- Tags for grouping

### Manual Testing
[Source: prd/epic-1 AC #10]

**From host machine:**
```bash
curl http://localhost:8000/health
curl http://localhost:8000/health/db
```

**From Docker container:**
```bash
docker exec kyros-shell-ui curl http://api:8000/health
docker exec kyros-dash-clv curl http://api:8000/health
```

This validates inter-service networking works correctly.

### Testing
[Source: architecture/15-testing-strategy.md]

**Definition of Done:**
- main.py created with FastAPI initialized
- /health endpoint returns correct format
- /health/db queries database and returns tenant count
- CORS middleware configured
- Database connection module works with aiosqlite
- Shared config loaded and logged on startup
- Error response format matches architecture spec
- OpenAPI docs accessible at /docs
- Unit tests pass
- Health endpoints accessible from host and Docker
- All acceptance criteria met

## Change Log
| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-10-11 | 0.1 | Initial story creation from Epic 1 | James (Dev Agent) |

## Dev Agent Record

### Agent Model Used
_(To be filled during implementation)_

### Debug Log References
_(To be filled during implementation)_

### Completion Notes List
_(To be filled during implementation)_

### File List
**Created:**
_(To be filled during implementation)_

**Modified:**
_(To be filled during implementation)_

## QA Results
_(To be filled by QA Agent)_
